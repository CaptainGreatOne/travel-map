---
phase: 22-deployment-preparation
plan: 02
type: execute
wave: 2
depends_on: ["22-01"]
files_modified: [Dockerfile, docker-compose.yml, .dockerignore]
autonomous: false
---

<objective>
Add Docker containerization and verify production build.

Purpose: Enable deployment via Docker for consistent environments. Verify the production build works correctly.
Output: Dockerfile, docker-compose.yml, .dockerignore, verified production build.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
@./.claude/get-shit-done/references/checkpoints.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/22-deployment-preparation/22-01-SUMMARY.md

@package.json
@vite.config.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Dockerfile</name>
  <files>Dockerfile</files>
  <action>
Create a multi-stage Dockerfile for production:

```dockerfile
# Build stage
FROM node:20-alpine AS builder

WORKDIR /app

# Copy package files
COPY package*.json ./

# Install dependencies
RUN npm ci

# Copy source
COPY . .

# Build for production
RUN npm run build

# Production stage
FROM nginx:alpine

# Copy built assets
COPY --from=builder /app/dist /usr/share/nginx/html

# Copy nginx config for SPA routing
COPY nginx.conf /etc/nginx/conf.d/default.conf

EXPOSE 80

CMD ["nginx", "-g", "daemon off;"]
```

Also create nginx.conf for SPA routing:
```nginx
server {
    listen 80;
    server_name localhost;
    root /usr/share/nginx/html;
    index index.html;

    # SPA routing - serve index.html for all routes
    location / {
        try_files $uri $uri/ /index.html;
    }

    # Cache static assets
    location ~* \.(js|css|png|jpg|jpeg|gif|ico|svg|woff|woff2)$ {
        expires 1y;
        add_header Cache-Control "public, immutable";
    }
}
```
  </action>
  <verify>Dockerfile exists: ls Dockerfile nginx.conf</verify>
  <done>Dockerfile and nginx.conf created for production deployment</done>
</task>

<task type="auto">
  <name>Task 2: Create docker-compose.yml</name>
  <files>docker-compose.yml</files>
  <action>
Create docker-compose.yml for easy local Docker deployment:

```yaml
version: '3.8'

services:
  app:
    build:
      context: .
      dockerfile: Dockerfile
    ports:
      - "3000:80"
    environment:
      - NODE_ENV=production
    restart: unless-stopped
```

Note: Environment variables (VITE_*) are baked in at build time for Vite apps, so they should be set before building. Add a comment in the file explaining this.
  </action>
  <verify>docker-compose.yml exists: ls docker-compose.yml</verify>
  <done>docker-compose.yml created for container orchestration</done>
</task>

<task type="auto">
  <name>Task 3: Create .dockerignore</name>
  <files>.dockerignore</files>
  <action>
Create .dockerignore to exclude unnecessary files from Docker context:

```
node_modules
dist
.git
.gitignore
.env.local
.env
*.md
!README.md
.planning
.claude
.vscode
*.log
.DS_Store
Thumbs.db
coverage
.nyc_output
```
  </action>
  <verify>.dockerignore exists: ls .dockerignore</verify>
  <done>.dockerignore created to optimize Docker builds</done>
</task>

<task type="auto">
  <name>Task 4: Verify production build</name>
  <files></files>
  <action>
Run production build and verify it succeeds:

1. Run: npm run build
2. Verify dist/ folder created with index.html and assets
3. Check for any build warnings or errors
4. Optionally run: npm run preview to test the build locally

Report any issues found.
  </action>
  <verify>npm run build succeeds and dist/index.html exists</verify>
  <done>Production build verified successfully</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
Complete deployment preparation:
- Comprehensive README.md with installation instructions
- Environment variable documentation in docs/ENVIRONMENT.md
- Consolidated supabase/seed.sql with all migrations
- Dockerfile for containerized deployment
- docker-compose.yml for easy container management
- .dockerignore for optimized builds
- Verified production build
  </what-built>
  <how-to-verify>
1. Review README.md - does it explain how to set up the project?
2. Check docs/ENVIRONMENT.md - are all env vars documented?
3. Verify supabase/seed.sql contains all table definitions
4. Run: npm run build (should succeed without errors)
5. Optionally test Docker: docker build -t travel-map . && docker run -p 3000:80 travel-map
6. Verify the app works when accessing http://localhost:3000

If pushing to GitHub:
7. Create repo on GitHub
8. git remote add origin <repo-url>
9. git push -u origin master
  </how-to-verify>
  <resume-signal>Type "approved" to complete Phase 22, or describe any issues</resume-signal>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] Dockerfile exists with multi-stage build
- [ ] nginx.conf exists for SPA routing
- [ ] docker-compose.yml exists
- [ ] .dockerignore exists
- [ ] npm run build succeeds
- [ ] Human verification passed
</verification>

<success_criteria>

- Docker configuration complete and functional
- Production build verified
- All deployment files in place
- Ready for GitHub push and production deployment
</success_criteria>

<output>
After completion, create `.planning/phases/22-deployment-preparation/22-02-SUMMARY.md`
</output>
