---
phase: 11-security-hardening
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/utils/parseGoogleMapsUrl.js
  - src/utils/sanitize.js
  - src/utils/parseGoogleMapsUrl.test.js
autonomous: true
---

<objective>
Create security utilities for URL validation and content sanitization.

Purpose: Establish reusable security functions that can be applied across forms.
Output: isValidGoogleMapsUrl validator with user-friendly errors, sanitizeUserContent utility for XSS prevention.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@.planning/phases/11-security-hardening/11-CONTEXT.md

@src/utils/parseGoogleMapsUrl.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Google Maps URL validation function</name>
  <files>src/utils/parseGoogleMapsUrl.js</files>
  <action>
Add a new function `isValidGoogleMapsUrl(url)` that validates URLs before processing:

1. Check URL is a string and not empty
2. Validate URL is a valid URL format (try new URL())
3. Validate domain is a Google Maps domain:
   - google.com/maps
   - maps.google.com
   - goo.gl/maps
   - maps.app.goo.gl
4. Return `{ valid: true }` if valid
5. Return `{ valid: false, error: 'Please enter a valid Google Maps URL' }` if invalid

This is the ONE place with user-facing error message (per CONTEXT.md).

Export the function.
  </action>
  <verify>Function exists and returns correct shape for valid/invalid URLs</verify>
  <done>isValidGoogleMapsUrl exported and validates Google Maps domains</done>
</task>

<task type="auto">
  <name>Task 2: Create content sanitization utility</name>
  <files>src/utils/sanitize.js</files>
  <action>
Create a new sanitization utility that prevents XSS:

1. `sanitizeUserContent(input)` function:
   - Return empty string for null/undefined
   - Trim whitespace
   - Escape HTML special characters: < > & " ' to their entity equivalents
   - This is sufficient for text content that will be displayed (React already escapes in JSX, but defense in depth)

2. `sanitizeForDatabase(input)` function:
   - Calls sanitizeUserContent
   - Additional: strips any null bytes (\0)
   - Trims to reasonable max length (10000 chars for text fields)

Keep it simple - no external library needed. These are for defense-in-depth since:
- React escapes JSX output (primary XSS defense)
- Supabase uses parameterized queries (primary SQL injection defense)
- This adds a sanitization layer at input time
  </action>
  <verify>Utility file exists with exported functions</verify>
  <done>sanitize.js exports sanitizeUserContent and sanitizeForDatabase</done>
</task>

<task type="auto">
  <name>Task 3: Add tests for URL validation</name>
  <files>src/utils/parseGoogleMapsUrl.test.js</files>
  <action>
Add tests for the new isValidGoogleMapsUrl function:

Test valid URLs (should return { valid: true }):
- https://www.google.com/maps/place/...
- https://maps.google.com/...
- https://goo.gl/maps/...
- https://maps.app.goo.gl/...

Test invalid URLs (should return { valid: false, error: '...' }):
- Empty string
- null/undefined
- Random text
- https://evil.com/maps/...
- https://google.com.evil.com/maps
- javascript:alert(1)

Ensure the error message is user-friendly (not technical).
  </action>
  <verify>npm test passes with new tests</verify>
  <done>URL validation tests cover valid and invalid cases</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] isValidGoogleMapsUrl function exists and exported
- [ ] sanitize.js exists with both functions exported
- [ ] Tests pass for URL validation
- [ ] npm run build succeeds
</verification>

<success_criteria>

- URL validation distinguishes Google Maps URLs from other domains
- Sanitization functions ready for integration
- Tests verify security functions work correctly
</success_criteria>

<output>
After completion, create `.planning/phases/11-security-hardening/11-01-SUMMARY.md`
</output>
