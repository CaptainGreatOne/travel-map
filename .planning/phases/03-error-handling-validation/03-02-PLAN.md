---
phase: 03-error-handling-validation
plan: 02
type: execute
wave: 1
depends_on: []
files_modified: [src/contexts/AuthContext.jsx, src/App.jsx, src/utils/fetchWithTimeout.js]
autonomous: true
---

<objective>
Add loading states and timeout handling to prevent indefinite loading.

Purpose: Users should never see indefinite spinners or wait forever. Auth state loads with visual feedback, and network requests have timeouts.
Output: Auth loading state in context, loading UI in App, fetchWithTimeout utility.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-error-handling-validation/03-CONTEXT.md

@src/contexts/AuthContext.jsx
@src/App.jsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add auth loading state</name>
  <files>src/contexts/AuthContext.jsx</files>
  <action>
The AuthContext already has a `loading` state - verify it's being exposed and used correctly.

Check current implementation:
- `loading` state exists and is set to `true` initially
- `loading` is set to `false` after session check completes
- `loading` is exposed in the context value

Add error handling to the session check:
- Wrap `supabase.auth.getSession()` in try/catch
- On error, still set loading to false (don't hang)
- Optionally add an `authError` state to expose errors

Add timeout protection:
- Create a Promise.race with a 10-second timeout
- If session check takes >10s, set loading false anyway
- Log timeout to console

Updated pattern:
```jsx
useEffect(() => {
  const checkSession = async () => {
    try {
      const sessionPromise = supabase.auth.getSession();
      const timeoutPromise = new Promise((_, reject) =>
        setTimeout(() => reject(new Error('Session check timeout')), 10000)
      );

      const { data: { session } } = await Promise.race([sessionPromise, timeoutPromise]);
      setUser(session?.user ?? null);
    } catch (error) {
      console.error('Auth session check failed:', error);
      setUser(null);
    } finally {
      setLoading(false);
    }
  };

  checkSession();
  // ... rest of listener setup
}, []);
```
  </action>
  <verify>AuthContext exports loading state, session check has timeout protection</verify>
  <done>AuthContext has robust loading state with timeout protection and error handling</done>
</task>

<task type="auto">
  <name>Task 2: Show loading UI during auth check</name>
  <files>src/App.jsx</files>
  <action>
Add a loading screen while the initial auth check happens.

Create a simple loading component inside App.jsx (or inline):
- Full screen, centered
- Simple "Loading..." text or a subtle spinner
- Matches app styling (bg-background, text colors)
- No fancy animations - keep it simple

In the App component:
- Import useAuth to get loading state
- If loading is true, show the loading UI instead of routes
- Once loading is false, show normal routes

Pattern:
```jsx
function AppContent() {
  const { loading } = useAuth();

  if (loading) {
    return (
      <div className="flex items-center justify-center h-screen bg-background">
        <div className="text-gray-500">Loading...</div>
      </div>
    );
  }

  return (
    <BrowserRouter>
      <Routes>...</Routes>
    </BrowserRouter>
  );
}

function App() {
  return (
    <AuthProvider>
      <ErrorBoundary>
        <AppContent />
      </ErrorBoundary>
    </AuthProvider>
  );
}
```

Note: useAuth must be called inside AuthProvider, so create an AppContent component that's wrapped by AuthProvider.
  </action>
  <verify>App shows loading state during initial auth check, then renders routes</verify>
  <done>App displays loading UI during auth initialization, no flash of undefined content</done>
</task>

<task type="auto">
  <name>Task 3: Create fetchWithTimeout utility</name>
  <files>src/utils/fetchWithTimeout.js</files>
  <action>
Create a utility function that wraps fetch with a timeout.

Requirements:
- Export a fetchWithTimeout function
- Accept same parameters as fetch (url, options)
- Add optional timeout parameter (default 30 seconds)
- Use AbortController to cancel fetch on timeout
- Throw descriptive error on timeout: "Request timed out"

Implementation:
```js
/**
 * Fetch with timeout - wraps native fetch with automatic timeout.
 * @param {string} url - The URL to fetch
 * @param {Object} options - Fetch options (method, headers, body, etc.)
 * @param {number} timeout - Timeout in milliseconds (default 30000)
 * @returns {Promise<Response>} - The fetch response
 * @throws {Error} - Throws on timeout or fetch error
 */
export async function fetchWithTimeout(url, options = {}, timeout = 30000) {
  const controller = new AbortController();
  const timeoutId = setTimeout(() => controller.abort(), timeout);

  try {
    const response = await fetch(url, {
      ...options,
      signal: controller.signal,
    });
    return response;
  } catch (error) {
    if (error.name === 'AbortError') {
      throw new Error('Request timed out');
    }
    throw error;
  } finally {
    clearTimeout(timeoutId);
  }
}
```

This utility can be used anywhere in the app where we do fetch requests (like the parseGoogleMapsUrlAsync function).
  </action>
  <verify>File exists, function exported, basic test: calling with invalid URL throws appropriate error</verify>
  <done>fetchWithTimeout utility created with proper timeout and AbortController handling</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run build` succeeds without errors
- [ ] App shows loading state briefly on initial load
- [ ] No flash of undefined content
- [ ] fetchWithTimeout utility exists and exports correctly
</verification>

<success_criteria>

- All tasks completed
- Auth loading state works with timeout protection
- Loading UI displays during initial auth check
- fetchWithTimeout utility available for network requests
</success_criteria>

<output>
After completion, create `.planning/phases/03-error-handling-validation/03-02-SUMMARY.md`
</output>
