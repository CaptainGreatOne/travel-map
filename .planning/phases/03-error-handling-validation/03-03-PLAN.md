---
phase: 03-error-handling-validation
plan: 03
type: execute
wave: 1
depends_on: []
files_modified: [src/utils/validation.js, src/components/SuggestForm.jsx, src/components/AuthModal.jsx]
autonomous: true
---

<objective>
Add form validation with clear, helpful feedback.

Purpose: Catch bad input before submission and give users clear feedback about what's wrong. Validation should be helpful, not punishing.
Output: Validation utility functions, validated SuggestForm and AuthModal.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-error-handling-validation/03-CONTEXT.md

@src/components/SuggestForm.jsx
@src/components/AuthModal.jsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create validation utility functions</name>
  <files>src/utils/validation.js</files>
  <action>
Create simple validation functions without heavy libraries (no Zod - keep it simple).

Export these functions:
```js
/**
 * Validate email format
 * @param {string} email
 * @returns {{ valid: boolean, message?: string }}
 */
export function validateEmail(email) {
  if (!email || !email.trim()) {
    return { valid: false, message: 'Email is required' };
  }
  // Simple email regex - not overly strict
  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  if (!emailRegex.test(email)) {
    return { valid: false, message: 'Please enter a valid email address' };
  }
  return { valid: true };
}

/**
 * Validate password (for signup)
 * @param {string} password
 * @param {number} minLength - default 6
 * @returns {{ valid: boolean, message?: string }}
 */
export function validatePassword(password, minLength = 6) {
  if (!password) {
    return { valid: false, message: 'Password is required' };
  }
  if (password.length < minLength) {
    return { valid: false, message: `Password must be at least ${minLength} characters` };
  }
  return { valid: true };
}

/**
 * Validate required text field
 * @param {string} value
 * @param {string} fieldName - for error message
 * @returns {{ valid: boolean, message?: string }}
 */
export function validateRequired(value, fieldName) {
  if (!value || !value.trim()) {
    return { valid: false, message: `${fieldName} is required` };
  }
  return { valid: true };
}

/**
 * Safely extract username from email (handles null/undefined)
 * @param {string|null|undefined} email
 * @returns {string}
 */
export function getUsernameFromEmail(email) {
  if (!email || typeof email !== 'string') {
    return 'user';
  }
  const parts = email.split('@');
  return parts[0] || 'user';
}
```

Keep messages matter-of-fact, not aggressive or apologetic.
  </action>
  <verify>File exists, all functions exported, simple test: validateEmail('') returns { valid: false }</verify>
  <done>Validation utility with email, password, required field validators, and safe email username extraction</done>
</task>

<task type="auto">
  <name>Task 2: Apply validation to SuggestForm</name>
  <files>src/components/SuggestForm.jsx</files>
  <action>
Add client-side validation to the suggestion form.

Changes:
1. Import validation functions:
   ```js
   import { validateRequired, getUsernameFromEmail } from '../utils/validation';
   ```

2. Add field-level validation state:
   ```js
   const [fieldErrors, setFieldErrors] = useState({});
   ```

3. Create validate function:
   ```js
   const validateForm = () => {
     const errors = {};

     const nameResult = validateRequired(locationName, 'Location name');
     if (!nameResult.valid) errors.locationName = nameResult.message;

     const reasonResult = validateRequired(reason, 'Reason');
     if (!reasonResult.valid) errors.reason = reasonResult.message;

     setFieldErrors(errors);
     return Object.keys(errors).length === 0;
   };
   ```

4. Call validateForm in handleSubmit before the try block:
   ```js
   if (!validateForm()) {
     return;
   }
   ```

5. Display field errors below inputs:
   ```jsx
   {fieldErrors.locationName && (
     <p className="mt-1 text-sm text-red-600">{fieldErrors.locationName}</p>
   )}
   ```

6. Replace `user.email.split('@')[0]` with `getUsernameFromEmail(user.email)` in both places (line 52 and line 148).

7. Clear field errors when user starts typing (in onChange handlers):
   ```js
   onChange={(e) => {
     setLocationName(e.target.value);
     setFieldErrors(prev => ({ ...prev, locationName: undefined }));
   }}
   ```

Keep existing HTML5 `required` attributes - they're a backup.
  </action>
  <verify>Form shows validation errors before submission, safe email handling used</verify>
  <done>SuggestForm validates fields before submission, displays inline errors, safely handles email</done>
</task>

<task type="auto">
  <name>Task 3: Apply validation to AuthModal</name>
  <files>src/components/AuthModal.jsx</files>
  <action>
Add validation to the auth modal for better feedback.

Changes:
1. Import validation functions:
   ```js
   import { validateEmail, validatePassword } from '../utils/validation';
   ```

2. Add field-level validation state:
   ```js
   const [fieldErrors, setFieldErrors] = useState({});
   ```

3. Create validate function:
   ```js
   const validateForm = () => {
     const errors = {};

     const emailResult = validateEmail(email);
     if (!emailResult.valid) errors.email = emailResult.message;

     // Only validate password strictly for signup
     const passwordResult = validatePassword(password, isSignUp ? 6 : 1);
     if (!passwordResult.valid) errors.password = passwordResult.message;

     setFieldErrors(errors);
     return Object.keys(errors).length === 0;
   };
   ```

4. Call validateForm at start of handleSubmit:
   ```js
   const handleSubmit = async (e) => {
     e.preventDefault();

     if (!validateForm()) {
       return;
     }

     setLoading(true);
     // ... rest of existing code
   };
   ```

5. Display field errors below each input:
   ```jsx
   {fieldErrors.email && (
     <p className="mt-1 text-sm text-red-600">{fieldErrors.email}</p>
   )}
   ```

6. Clear field errors when user types:
   ```js
   onChange={(e) => {
     setEmail(e.target.value);
     setFieldErrors(prev => ({ ...prev, email: undefined }));
   }}
   ```

7. Clear field errors when switching between sign in/sign up:
   ```js
   onClick={() => {
     setIsSignUp(!isSignUp);
     setError(null);
     setMessage(null);
     setFieldErrors({});
   }}
   ```
  </action>
  <verify>Auth modal shows validation errors for empty/invalid fields before API call</verify>
  <done>AuthModal validates email and password with inline error display</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run build` succeeds without errors
- [ ] Validation utility functions exist and work
- [ ] SuggestForm shows errors for empty required fields
- [ ] AuthModal shows errors for invalid email/short password
- [ ] No crashes when user.email is null/undefined
</verification>

<success_criteria>

- All tasks completed
- Forms validate before submission
- Helpful error messages displayed inline
- Safe email handling prevents crashes
</success_criteria>

<output>
After completion, create `.planning/phases/03-error-handling-validation/03-03-SUMMARY.md`
</output>
