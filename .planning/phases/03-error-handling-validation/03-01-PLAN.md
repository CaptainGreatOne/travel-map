---
phase: 03-error-handling-validation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [src/components/ErrorBoundary.jsx, src/components/MapErrorBoundary.jsx, src/App.jsx, src/pages/MapPage.jsx]
autonomous: true
---

<objective>
Implement error boundaries to prevent white screen crashes.

Purpose: Catch React errors gracefully so the app never crashes to a blank white screen. Map errors get special treatment since the map is the core experience.
Output: ErrorBoundary and MapErrorBoundary components, App wrapped with error boundaries.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-error-handling-validation/03-CONTEXT.md

@src/App.jsx
@src/pages/MapPage.jsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ErrorBoundary component</name>
  <files>src/components/ErrorBoundary.jsx</files>
  <action>
Create a React class component that catches JavaScript errors in child components.

Requirements:
- Use React's componentDidCatch and getDerivedStateFromError lifecycle methods
- Display a friendly, matter-of-fact error message: "Something went wrong. Try refreshing the page."
- Style with Tailwind: centered message, muted colors, not alarming
- Include a "Refresh Page" button that calls window.location.reload()
- Log errors to console for debugging (console.error)
- Accept optional `fallback` prop to customize the error UI
- Accept optional `onError` callback prop

Pattern:
```jsx
class ErrorBoundary extends React.Component {
  state = { hasError: false, error: null };

  static getDerivedStateFromError(error) {
    return { hasError: true, error };
  }

  componentDidCatch(error, errorInfo) {
    console.error('ErrorBoundary caught:', error, errorInfo);
    this.props.onError?.(error, errorInfo);
  }

  render() {
    if (this.state.hasError) {
      return this.props.fallback || <DefaultFallback />;
    }
    return this.props.children;
  }
}
```

Keep it simple - no retry buttons per user vision (refresh or move on).
  </action>
  <verify>File exists and exports ErrorBoundary component</verify>
  <done>ErrorBoundary component created with class-based error catching, friendly fallback UI, and refresh button</done>
</task>

<task type="auto">
  <name>Task 2: Create MapErrorBoundary component</name>
  <files>src/components/MapErrorBoundary.jsx</files>
  <action>
Create a specialized error boundary for the map area with map-specific messaging.

Requirements:
- Extend or wrap the base ErrorBoundary concept
- Display map-specific message: "Couldn't load the map. Try refreshing the page."
- Style to fit within the map container area (full height/width of map area)
- Include a map icon (from lucide-react, e.g., MapPinOff or AlertTriangle)
- Muted, calm styling - not scary

This component wraps the MapContainer and its children. If Leaflet or tile loading fails, users see this instead of a crash.
  </action>
  <verify>File exists and exports MapErrorBoundary component</verify>
  <done>MapErrorBoundary component created with map-specific error message and appropriate styling</done>
</task>

<task type="auto">
  <name>Task 3: Wrap App with error boundaries</name>
  <files>src/App.jsx, src/pages/MapPage.jsx</files>
  <action>
Apply error boundaries to the application.

In App.jsx:
- Import ErrorBoundary
- Wrap the BrowserRouter (inside AuthProvider) with ErrorBoundary
- This catches any unhandled errors in the entire app

In MapPage.jsx:
- Import MapErrorBoundary
- Wrap the MapContainer (the div containing it) with MapErrorBoundary
- The map-specific boundary catches Leaflet errors and shows map-specific message

Structure:
```jsx
// App.jsx
<AuthProvider>
  <ErrorBoundary>
    <BrowserRouter>
      ...
    </BrowserRouter>
  </ErrorBoundary>
</AuthProvider>

// MapPage.jsx
const mapContent = (
  <MapErrorBoundary>
    <div className="flex-1 relative isolate z-0...">
      <MapContainer ...>
  </MapErrorBoundary>
);
```

Note: The map boundary is nested inside the app boundary, so map errors show map-specific UI while other errors show generic UI.
  </action>
  <verify>npm run build succeeds, app renders without errors</verify>
  <done>App.jsx wrapped with ErrorBoundary, MapPage.jsx map section wrapped with MapErrorBoundary</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run build` succeeds without errors
- [ ] App loads normally in browser
- [ ] ErrorBoundary component exists and exports correctly
- [ ] MapErrorBoundary component exists and exports correctly
</verification>

<success_criteria>

- All tasks completed
- Error boundaries properly wrap application
- No build errors introduced
- App continues to function normally
</success_criteria>

<output>
After completion, create `.planning/phases/03-error-handling-validation/03-01-SUMMARY.md`
</output>
