---
phase: 04-database-schema-redesign
plan: 03
type: execute
wave: 2
depends_on: ["04-01", "04-02"]
files_modified: [src/services/locationService.js, src/services/suggestionService.js, src/pages/MapPage.jsx, src/components/SuggestForm.jsx]
autonomous: true
---

<objective>
Integrate the app with the new database schema by creating service layers and updating components.

Purpose: Replace static sampleData.js usage with real Supabase queries, and update the suggestion form to work with the new schema.
Output: Working data layer with fallback to sample data for development.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-database-schema-redesign/04-CONTEXT.md

@src/utils/supabaseClient.js
@src/data/sampleData.js
@src/pages/MapPage.jsx
@src/components/SuggestForm.jsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create location service</name>
  <files>src/services/locationService.js</files>
  <action>
Create new file `src/services/locationService.js` with the following functions:

**1. fetchLocations()**
```javascript
// Fetches all locations with their category info
// Returns: Array of location objects
// Falls back to sampleData if DB query fails (for development)

async function fetchLocations() {
  const { data, error } = await supabase
    .from('locations')
    .select(`
      *,
      category:categories(*)
    `)
    .order('name');

  if (error) {
    console.warn('Failed to fetch locations from DB, using sample data:', error.message);
    return null; // Caller should fall back to sampleData
  }

  return data;
}
```

**2. fetchCategories()**
```javascript
// Fetches all categories
// Returns: Array of category objects

async function fetchCategories() {
  const { data, error } = await supabase
    .from('categories')
    .select('*')
    .order('name');

  if (error) {
    console.warn('Failed to fetch categories from DB:', error.message);
    return null;
  }

  return data;
}
```

**3. fetchLocationWithVideos(locationId)**
```javascript
// Fetches a single location with its linked videos
// Returns: Location object with videos array

async function fetchLocationWithVideos(locationId) {
  const { data, error } = await supabase
    .from('locations')
    .select(`
      *,
      category:categories(*),
      videos:location_videos(
        display_order,
        video:videos(*)
      )
    `)
    .eq('id', locationId)
    .single();

  if (error) {
    console.error('Failed to fetch location:', error.message);
    return null;
  }

  // Flatten the videos array and sort by display_order
  if (data?.videos) {
    data.videos = data.videos
      .sort((a, b) => a.display_order - b.display_order)
      .map(lv => lv.video);
  }

  return data;
}
```

Export all functions as named exports.
Import supabase from '../utils/supabaseClient'.
  </action>
  <verify>File exists with all three functions: `grep -c "async function" src/services/locationService.js` returns 3</verify>
  <done>locationService.js created with fetchLocations, fetchCategories, fetchLocationWithVideos functions</done>
</task>

<task type="auto">
  <name>Task 2: Create suggestion service</name>
  <files>src/services/suggestionService.js</files>
  <action>
Create new file `src/services/suggestionService.js` with the following functions:

**1. submitSuggestion(userId, data)**
```javascript
// Submits a new location suggestion
// data: { locationName, googleMapsUrl, latitude, longitude, reason }
// Returns: { success: boolean, error?: string }

async function submitSuggestion(userId, data) {
  const { error } = await supabase
    .from('suggestions')
    .insert({
      user_id: userId,
      location_name: data.locationName,
      google_maps_url: data.googleMapsUrl || null,
      latitude: data.latitude || null,
      longitude: data.longitude || null,
      reason: data.reason
    });

  if (error) {
    // Check for rate limit error from trigger
    if (error.message.includes('limit reached')) {
      return { success: false, error: 'You have reached your monthly suggestion limit (1 per month).' };
    }
    return { success: false, error: error.message };
  }

  return { success: true };
}
```

**2. submitReminder(userId, locationId, message)**
```javascript
// Submits a reminder for an existing location
// Returns: { success: boolean, error?: string }

async function submitReminder(userId, locationId, message = null) {
  const { error } = await supabase
    .from('reminders')
    .insert({
      user_id: userId,
      location_id: locationId,
      message: message
    });

  if (error) {
    // Check for rate limit error
    if (error.message.includes('limit reached')) {
      return { success: false, error: 'You have reached your monthly reminder limit (3 per month).' };
    }
    // Check for duplicate
    if (error.code === '23505') {
      return { success: false, error: 'You have already reminded about this location.' };
    }
    return { success: false, error: error.message };
  }

  return { success: true };
}
```

**3. getUserLimits(userId)**
```javascript
// Gets current month's suggestion and reminder counts for a user
// Returns: { suggestionsUsed: number, remindersUsed: number }

async function getUserLimits(userId) {
  const currentMonth = new Date().toISOString().slice(0, 7); // 'YYYY-MM'

  const [suggestionRes, reminderRes] = await Promise.all([
    supabase
      .from('user_suggestion_counts')
      .select('suggestion_count')
      .eq('user_id', userId)
      .eq('year_month', currentMonth)
      .single(),
    supabase
      .from('user_reminder_counts')
      .select('reminder_count')
      .eq('user_id', userId)
      .eq('year_month', currentMonth)
      .single()
  ]);

  return {
    suggestionsUsed: suggestionRes.data?.suggestion_count || 0,
    remindersUsed: reminderRes.data?.reminder_count || 0
  };
}
```

Export all functions as named exports.
Import supabase from '../utils/supabaseClient'.
  </action>
  <verify>File exists with all three functions: `grep -c "async function" src/services/suggestionService.js` returns 3</verify>
  <done>suggestionService.js created with submitSuggestion, submitReminder, getUserLimits functions</done>
</task>

<task type="auto">
  <name>Task 3: Update MapPage to use location service</name>
  <files>src/pages/MapPage.jsx</files>
  <action>
Update MapPage.jsx to fetch locations from the database:

**1. Add imports:**
```javascript
import { useEffect } from 'react'; // Add useEffect to existing React import
import { fetchLocations, fetchCategories } from '../services/locationService';
```

**2. Replace static locations with fetched data:**

Change:
```javascript
const [locations] = useState(sampleLocations);
```

To:
```javascript
const [locations, setLocations] = useState(sampleLocations); // Start with sample as fallback
const [categories, setCategories] = useState(categoryData); // Start with sample as fallback
const [isLoading, setIsLoading] = useState(true);

useEffect(() => {
  async function loadData() {
    const [dbLocations, dbCategories] = await Promise.all([
      fetchLocations(),
      fetchCategories()
    ]);

    if (dbLocations) {
      setLocations(dbLocations);
    }
    if (dbCategories) {
      setCategories(dbCategories);
    }
    setIsLoading(false);
  }

  loadData();
}, []);
```

**3. Update useMapFilters call:**

Change:
```javascript
} = useMapFilters(locations, categoryData);
```

To:
```javascript
} = useMapFilters(locations, categories);
```

**4. Add loading indicator (optional but nice):**
If isLoading is true, show a brief loading state or just render normally (sample data is shown immediately as fallback).

Keep the sampleLocations and categoryData imports as fallbacks - they ensure the app works even if DB is not configured.
  </action>
  <verify>MapPage imports fetchLocations: `grep "fetchLocations" src/pages/MapPage.jsx`</verify>
  <done>MapPage fetches locations from DB with fallback to sample data</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] src/services/ directory created
- [ ] locationService.js has fetchLocations, fetchCategories, fetchLocationWithVideos
- [ ] suggestionService.js has submitSuggestion, submitReminder, getUserLimits
- [ ] MapPage imports and uses fetchLocations
- [ ] MapPage falls back to sampleData if DB unavailable
- [ ] No TypeScript errors (this is a JS project but ensure imports are correct)
</verification>

<success_criteria>

- All tasks completed
- Services export proper async functions
- MapPage fetches from DB on load
- Fallback to sample data works when DB not available
- App still runs with `npm run dev`
</success_criteria>

<output>
After completion, create `.planning/phases/04-database-schema-redesign/04-03-SUMMARY.md`
</output>
